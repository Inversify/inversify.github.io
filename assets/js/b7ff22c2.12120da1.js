"use strict";(self.webpackChunk_inversifyjs_inversify_docs_site=self.webpackChunk_inversifyjs_inversify_docs_site||[]).push([["5305"],{6416:function(e,n,i){i.r(n),i.d(n,{default:()=>h,frontMatter:()=>s,metadata:()=>a,assets:()=>d,toc:()=>l,contentTitle:()=>c});var a=JSON.parse('{"id":"fundamentals/di-hierarchy","title":"DI Hierarchy","description":"InversifyJS is a popular library for implementing inversion of control (IoC) and dependency injection (DI) in TypeScript applications. It supports hierarchical dependency injection, which can be a powerful tool in complex applications.","source":"@site/docs/fundamentals/di-hierarchy.mdx","sourceDirName":"fundamentals","slug":"/fundamentals/di-hierarchy","permalink":"/docs/next/fundamentals/di-hierarchy","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"DI Hierarchy"},"sidebar":"tutorialSidebar","previous":{"title":"Binding","permalink":"/docs/next/fundamentals/binding"},"next":{"title":"Activation","permalink":"/docs/next/fundamentals/lifecycle/activation"}}'),t=i("1514"),r=i("8456"),o=i("9471");let s={sidebar_position:2,title:"DI Hierarchy"},c="DI Hierarchy",d={},l=[];function p(e){let n={h1:"h1",header:"header",p:"p",...(0,r.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"di-hierarchy",children:"DI Hierarchy"})}),"\n",(0,t.jsx)(n.p,{children:"InversifyJS is a popular library for implementing inversion of control (IoC) and dependency injection (DI) in TypeScript applications. It supports hierarchical dependency injection, which can be a powerful tool in complex applications."}),"\n",(0,t.jsx)(n.p,{children:"With InversifyJS's hierarchical injection system, you can create a hierarchy of containers where each container can have a parent container. This allows for better organization and separation of concerns in your application."}),"\n",(0,t.jsx)(n.p,{children:"When a dependency needs to be injected, InversifyJS starts by looking in the current container for a binding. If the binding is not found, it moves up the hierarchy to the parent container and continues the search. This process continues until the dependency is resolved or the top-level parent container is reached."}),"\n",(0,t.jsx)(n.p,{children:"By using InversifyJS's hierarchical injection system, you can easily manage complex dependencies and keep your code clean and modular. It provides a flexible and scalable solution for handling dependencies in your TypeScript applications."}),"\n",(0,t.jsx)(o.Z,{language:"ts",children:"class Katana {}\n\nconst parentContainer: Container = new Container();\nparentContainer.bind(weaponIdentifier).to(Katana);\n\nconst childContainer: Container = new Container({ parent: parentContainer });\n\nconst katana: Katana = childContainer.get(weaponIdentifier);"})]})}function h(e={}){let{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(p,{...e})}):p(e)}}}]);